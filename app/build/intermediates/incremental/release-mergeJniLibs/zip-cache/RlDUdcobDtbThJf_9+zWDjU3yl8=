/*!
 * (C) Ionic http://ionicframework.com - MIT License
 * Built with http://stenciljs.com
 */
var __awaiter=this&&this.__awaiter||function(t,e,n,i){return new(n||(n=Promise))(function(o,r){function s(t){try{u(i.next(t))}catch(t){r(t)}}function a(t){try{u(i.throw(t))}catch(t){r(t)}}function u(t){t.done?o(t.value):new n(function(e){e(t.value)}).then(s,a)}u((i=i.apply(t,e||[])).next())})},__generator=this&&this.__generator||function(t,e){var n,i,o,r,s={label:0,sent:function(){if(1&o[0])throw o[1];return o[1]},trys:[],ops:[]};return r={next:a(0),throw:a(1),return:a(2)},"function"==typeof Symbol&&(r[Symbol.iterator]=function(){return this}),r;function a(r){return function(a){return function(r){if(n)throw new TypeError("Generator is already executing.");for(;s;)try{if(n=1,i&&(o=2&r[0]?i.return:r[0]?i.throw||((o=i.return)&&o.call(i),0):i.next)&&!(o=o.call(i,r[1])).done)return o;switch(i=0,o&&(r=[2&r[0],o.value]),r[0]){case 0:case 1:o=r;break;case 4:return s.label++,{value:r[1],done:!1};case 5:s.label++,i=r[1],r=[0];continue;case 7:r=s.ops.pop(),s.trys.pop();continue;default:if(!(o=(o=s.trys).length>0&&o[o.length-1])&&(6===r[0]||2===r[0])){s=0;continue}if(3===r[0]&&(!o||r[1]>o[0]&&r[1]<o[3])){s.label=r[1];break}if(6===r[0]&&s.label<o[1]){s.label=o[1],o=r;break}if(o&&s.label<o[2]){s.label=o[2],s.ops.push(r);break}o[2]&&s.ops.pop(),s.trys.pop();continue}r=e.call(t,s)}catch(t){r=[6,t],i=0}finally{n=o=0}if(5&r[0])throw r[1];return{value:r[0]?r[1]:void 0,done:!0}}([r,a])}}};Ionic.loadBundle("tf1aqcsl",["require","exports","./chunk-7525b79e.js"],function(t,e,n){var i=window.Ionic.h,o=function(){function e(){this.lastOnEnd=0,this.isAnimating=!1,this._isOpen=!1,this.isPaneVisible=!1,this.isEndSide=!1,this.disabled=!1,this.side="start",this.swipeGesture=!0,this.maxEdgeStart=50}return e.prototype.typeChanged=function(t,e){var n=this.contentEl;n&&e&&(n.classList.remove("menu-content-"+e),n.classList.add("menu-content-"+t),n.removeAttribute("style")),this.menuInnerEl&&this.menuInnerEl.removeAttribute("style"),this.animation=void 0},e.prototype.disabledChanged=function(){this.updateState(),this.ionMenuChange.emit({disabled:this.disabled,open:this._isOpen})},e.prototype.sideChanged=function(){this.isEndSide=n.isEndSide(this.win,this.side)},e.prototype.swipeGestureChanged=function(){this.updateState()},e.prototype.componentWillLoad=function(){return __awaiter(this,void 0,void 0,function(){var t;return __generator(this,function(e){switch(e.label){case 0:return null==this.type&&(this.type=this.config.get("menuType","ios"===this.mode?"reveal":"overlay")),this.isServer?(this.disabled=!0,[3,3]):[3,1];case 1:return t=this,[4,this.lazyMenuCtrl.componentOnReady()];case 2:t.menuCtrl=e.sent(),e.label=3;case 3:return[2]}})})},e.prototype.componentDidLoad=function(){return __awaiter(this,void 0,void 0,function(){var e,n,i,o,r,s,a=this;return __generator(this,function(u){switch(u.label){case 0:return this.isServer?[2]:(e=this.el,n=e.parentNode,(i=this.contentId?document.getElementById(this.contentId):n&&n.querySelector&&n.querySelector("[main]"))&&i.tagName?(this.contentEl=i,i.classList.add("menu-content"),this.typeChanged(this.type,null),this.sideChanged(),!0!=(o=!this.disabled)&&void 0!==o?[3,2]:[4,this.menuCtrl.getMenus()]):(console.error('Menu: must have a "content" element to listen for drag events on.'),[2]));case 1:r=u.sent(),o=!r.some(function(t){return t.side===a.side&&!t.disabled}),u.label=2;case 2:return this.menuCtrl._register(this),this.ionMenuChange.emit({disabled:!o,open:this._isOpen}),s=this,[4,new Promise(function(e,n){t(["./gesture.js"],e,n)})];case 3:return s.gesture=u.sent().createGesture({el:this.doc,queue:this.queue,gestureName:"menu-swipe",gesturePriority:40,threshold:10,canStart:this.canStart.bind(this),onWillStart:this.onWillStart.bind(this),onStart:this.onStart.bind(this),onMove:this.onMove.bind(this),onEnd:this.onEnd.bind(this)}),this.disabled=!o,this.updateState(),[2]}})})},e.prototype.componentDidUnload=function(){this.menuCtrl._unregister(this),this.animation&&this.animation.destroy(),this.gesture&&this.gesture.destroy(),this.animation=void 0,this.contentEl=this.backdropEl=this.menuInnerEl=void 0},e.prototype.onSplitPaneChanged=function(t){this.isPaneVisible=t.detail.isPane(this.el),this.updateState()},e.prototype.onBackdropClick=function(t){this.lastOnEnd<t.timeStamp-100&&t.composedPath&&!t.composedPath().includes(this.menuInnerEl)&&(t.preventDefault(),t.stopPropagation(),this.close())},e.prototype.isOpen=function(){return Promise.resolve(this._isOpen)},e.prototype.isActive=function(){return Promise.resolve(this._isActive())},e.prototype.open=function(t){return void 0===t&&(t=!0),this.setOpen(!0,t)},e.prototype.close=function(t){return void 0===t&&(t=!0),this.setOpen(!1,t)},e.prototype.toggle=function(t){return void 0===t&&(t=!0),this.setOpen(!this._isOpen,t)},e.prototype.setOpen=function(t,e){return void 0===e&&(e=!0),this.menuCtrl._setOpen(this,t,e)},e.prototype._setOpen=function(t,e){return void 0===e&&(e=!0),__awaiter(this,void 0,void 0,function(){return __generator(this,function(n){switch(n.label){case 0:return!this._isActive()||this.isAnimating||t===this._isOpen?[2,this._isOpen]:(this.beforeAnimation(),[4,this.loadAnimation()]);case 1:return n.sent(),[4,this.startAnimation(t,e)];case 2:return n.sent(),this.afterAnimation(t),[2,t]}})})},e.prototype.loadAnimation=function(){return __awaiter(this,void 0,void 0,function(){var t,e;return __generator(this,function(n){switch(n.label){case 0:return(t=this.menuInnerEl.offsetWidth)===this.width&&void 0!==this.animation?[2]:(this.width=t,this.animation&&(this.animation.destroy(),this.animation=void 0),e=this,[4,this.menuCtrl.createAnimation(this.type,this)]);case 1:return e.animation=n.sent(),[2]}})})},e.prototype.startAnimation=function(t,e){return __awaiter(this,void 0,void 0,function(){var n;return __generator(this,function(i){switch(i.label){case 0:return n=this.animation.reverse(!t),e?[4,n.playAsync()]:[3,2];case 1:return i.sent(),[3,3];case 2:n.playSync(),i.label=3;case 3:return[2]}})})},e.prototype._isActive=function(){return!this.disabled&&!this.isPaneVisible},e.prototype.canSwipe=function(){return this.swipeGesture&&!this.isAnimating&&this._isActive()},e.prototype.canStart=function(t){return!!this.canSwipe()&&(!!this._isOpen||!this.menuCtrl.getOpen()&&(e=this.win,n=t.currentX,i=this.isEndSide,o=this.maxEdgeStart,i?n>=e.innerWidth-o:n<=o));var e,n,i,o},e.prototype.onWillStart=function(){return this.beforeAnimation(),this.loadAnimation()},e.prototype.onStart=function(){this.isAnimating&&this.animation?this.animation.reverse(this._isOpen).progressStart():n.assert(!1,"isAnimating has to be true")},e.prototype.onMove=function(t){if(this.isAnimating&&this.animation){var e=r(t.deltaX,this._isOpen,this.isEndSide)/this.width;this.animation.progressStep(e)}else n.assert(!1,"isAnimating has to be true")},e.prototype.onEnd=function(t){var e=this;if(this.isAnimating&&this.animation){var i=this._isOpen,o=this.isEndSide,s=r(t.deltaX,i,o),a=this.width,u=s/a,l=t.velocityX,c=a/2,h=l>=0&&(l>.2||t.deltaX>c),d=l<=0&&(l<-.2||t.deltaX<-c),p=i?o?h:d:o?d:h,m=!i&&p;i&&!p&&(m=!0);var b=(p?1-u:u)*a,f=0;if(b>5){var g=b/Math.abs(l);f=Math.min(g,300)}this.lastOnEnd=t.timeStamp,this.animation.onFinish(function(){return e.afterAnimation(m)},{clearExistingCallacks:!0}).progressEnd(p,u,f)}else n.assert(!1,"isAnimating has to be true")},e.prototype.beforeAnimation=function(){n.assert(!this.isAnimating,"_before() should not be called while animating"),this.el.classList.add(s),this.backdropEl&&this.backdropEl.classList.add(a),this.isAnimating=!0},e.prototype.afterAnimation=function(t){n.assert(this.isAnimating,"_before() should be called while animating"),this._isOpen=t,this.isAnimating=!1,this.enableListener(this,"body:click",t),t?(this.contentEl&&this.contentEl.classList.add(u),this.ionOpen.emit()):(this.el.classList.remove(s),this.contentEl&&this.contentEl.classList.remove(u),this.backdropEl&&this.backdropEl.classList.remove(a),this.ionClose.emit())},e.prototype.updateState=function(){var t=this._isActive();this.gesture&&this.gesture.setDisabled(!t||!this.swipeGesture),!t&&this._isOpen&&this.forceClosing(),!this.disabled&&this.menuCtrl&&this.menuCtrl._setActiveMenu(this),n.assert(!this.isAnimating,"can not be animating")},e.prototype.forceClosing=function(){n.assert(this._isOpen,"menu cannot be closed"),this.isAnimating=!0,this.startAnimation(!1,!1),this.afterAnimation(!1)},e.prototype.hostData=function(){var t,e=this.isEndSide,n=this.type,i=this.disabled,o=this.isPaneVisible;return{role:"complementary",class:(t={},t["menu-type-"+n]=!0,t["menu-enabled"]=!i,t["menu-side-end"]=e,t["menu-side-start"]=!e,t["menu-pane-visible"]=o,t)}},e.prototype.render=function(){var t=this;return[i("div",{class:"menu-inner",ref:function(e){return t.menuInnerEl=e}},i("slot",null)),i("ion-backdrop",{ref:function(e){return t.backdropEl=e},class:"menu-backdrop",tappable:!1,stopPropagation:!1})]},Object.defineProperty(e,"is",{get:function(){return"ion-menu"},enumerable:!0,configurable:!0}),Object.defineProperty(e,"encapsulation",{get:function(){return"shadow"},enumerable:!0,configurable:!0}),Object.defineProperty(e,"properties",{get:function(){return{close:{method:!0},config:{context:"config"},contentId:{type:String,attr:"content-id"},disabled:{type:Boolean,attr:"disabled",mutable:!0,watchCallbacks:["disabledChanged"]},doc:{context:"document"},el:{elementRef:!0},enableListener:{context:"enableListener"},isActive:{method:!0},isEndSide:{state:!0},isOpen:{method:!0},isPaneVisible:{state:!0},isServer:{context:"isServer"},lazyMenuCtrl:{connect:"ion-menu-controller"},maxEdgeStart:{type:Number,attr:"max-edge-start"},menuId:{type:String,attr:"menu-id"},open:{method:!0},queue:{context:"queue"},setOpen:{method:!0},side:{type:String,attr:"side",reflectToAttr:!0,watchCallbacks:["sideChanged"]},swipeGesture:{type:Boolean,attr:"swipe-gesture",watchCallbacks:["swipeGestureChanged"]},toggle:{method:!0},type:{type:String,attr:"type",mutable:!0,watchCallbacks:["typeChanged"]},win:{context:"window"}}},enumerable:!0,configurable:!0}),Object.defineProperty(e,"events",{get:function(){return[{name:"ionOpen",method:"ionOpen",bubbles:!0,cancelable:!0,composed:!0},{name:"ionClose",method:"ionClose",bubbles:!0,cancelable:!0,composed:!0},{name:"ionMenuChange",method:"ionMenuChange",bubbles:!0,cancelable:!0,composed:!0}]},enumerable:!0,configurable:!0}),Object.defineProperty(e,"listeners",{get:function(){return[{name:"body:ionSplitPaneVisible",method:"onSplitPaneChanged"},{name:"body:click",method:"onBackdropClick",capture:!0,disabled:!0}]},enumerable:!0,configurable:!0}),Object.defineProperty(e,"style",{get:function(){return":host{--width:304px;--width-small:264px;left:0;right:0;top:0;bottom:0;display:none;position:absolute;contain:strict}:host(.show-menu){display:block}.menu-inner{left:0;right:auto;top:0;bottom:0;-webkit-transform:translate3d(-9999px,0,0);transform:translate3d(-9999px,0,0);display:-webkit-box;display:-ms-flexbox;display:flex;position:absolute;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between;width:var(--width);height:100%;contain:strict;background:var(--ion-background-color,#fff)}:host(.menu-side-start) .menu-inner{right:auto;left:0}:host(.menu-side-end) .menu-inner{right:0;left:auto}ion-backdrop{display:none;opacity:.01;z-index:-1}.menu-content{-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0)}.menu-content-open{cursor:pointer;-ms-touch-action:manipulation;touch-action:manipulation;pointer-events:none}\@media (max-width:340px){.menu-inner{width:var(--width-small)}}:host(.menu-type-reveal){z-index:0}:host(.menu-type-reveal.show-menu) .menu-inner{-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0)}:host(.menu-type-overlay){z-index:80}:host(.menu-type-overlay) .show-backdrop{display:block;cursor:pointer}:host(.menu-pane-visible) .menu-inner{left:0;right:0;width:auto;-webkit-transform:none!important;transform:none!important;-webkit-box-shadow:none!important;box-shadow:none!important}:host(.menu-pane-visible) ion-backdrop{display:hidden!important}:host(.menu-type-push){z-index:80}:host(.menu-type-push) .show-backdrop{display:block}"},enumerable:!0,configurable:!0}),Object.defineProperty(e,"styleMode",{get:function(){return"ios"},enumerable:!0,configurable:!0}),e}();function r(t,e,n){return Math.max(0,e!==n?-t:t)}var s="show-menu",a="show-backdrop",u="menu-content-open",l=function(){function t(){this.autoHide=!0}return t.prototype.hostData=function(){return{class:{button:!0}}},t.prototype.render=function(){var t=this.config.get("menuIcon","menu");return i("ion-menu-toggle",{menu:this.menu,autoHide:this.autoHide},i("button",{type:"button"},i("slot",null,i("ion-icon",{icon:t,mode:this.mode,color:this.color,lazy:!1}))))},Object.defineProperty(t,"is",{get:function(){return"ion-menu-button"},enumerable:!0,configurable:!0}),Object.defineProperty(t,"encapsulation",{get:function(){return"shadow"},enumerable:!0,configurable:!0}),Object.defineProperty(t,"properties",{get:function(){return{autoHide:{type:Boolean,attr:"auto-hide"},color:{type:String,attr:"color"},config:{context:"config"},menu:{type:String,attr:"menu"},mode:{type:String,attr:"mode"}}},enumerable:!0,configurable:!0}),Object.defineProperty(t,"style",{get:function(){return":host{pointer-events:all;text-align:center;text-decoration:none;text-overflow:ellipsis;text-transform:none;white-space:nowrap;-webkit-font-kerning:none;font-kerning:none;color:var(--ion-color-primary,#3880ff)}button{font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;margin:0;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;display:-webkit-box;display:-ms-flexbox;display:flex;position:relative;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-flow:row nowrap;flex-flow:row nowrap;-ms-flex-negative:0;flex-shrink:0;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;height:32px;border:0;outline:0;background:0 0;line-height:1;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;z-index:0;-webkit-appearance:none;-moz-appearance:none;appearance:none;padding:0 5px}ion-icon{margin:0;padding:0;pointer-events:none;font-size:31px}"},enumerable:!0,configurable:!0}),Object.defineProperty(t,"styleMode",{get:function(){return"ios"},enumerable:!0,configurable:!0}),t}(),c=function(){function t(){this.visible=!1,this.autoHide=!0}return t.prototype.componentDidLoad=function(){this.updateVisibility()},t.prototype.onClick=function(){return __awaiter(this,void 0,void 0,function(){var t;return __generator(this,function(e){switch(e.label){case 0:return[4,h(this.doc)];case 1:return(t=e.sent())?[4,t.get(this.menu)]:[3,3];case 2:if(e.sent())return[2,t.toggle(this.menu)];e.label=3;case 3:return[2,!1]}})})},t.prototype.updateVisibility=function(){return __awaiter(this,void 0,void 0,function(){var t,e,n;return __generator(this,function(i){switch(i.label){case 0:return[4,h(this.doc)];case 1:return(t=i.sent())?[4,t.get(this.menu)]:[3,5];case 2:return e=i.sent(),(n=e)?[4,e.isActive()]:[3,4];case 3:n=i.sent(),i.label=4;case 4:if(n)return this.visible=!0,[2];i.label=5;case 5:return this.visible=!1,[2]}})})},t.prototype.hostData=function(){var t=this.autoHide&&!this.visible;return{"aria-hidden":t?"true":null,class:{"menu-toggle-hidden":t}}},t.prototype.render=function(){return i("slot",null)},Object.defineProperty(t,"is",{get:function(){return"ion-menu-toggle"},enumerable:!0,configurable:!0}),Object.defineProperty(t,"encapsulation",{get:function(){return"shadow"},enumerable:!0,configurable:!0}),Object.defineProperty(t,"properties",{get:function(){return{autoHide:{type:Boolean,attr:"auto-hide"},doc:{context:"document"},menu:{type:String,attr:"menu"},visible:{state:!0}}},enumerable:!0,configurable:!0}),Object.defineProperty(t,"listeners",{get:function(){return[{name:"click",method:"onClick"},{name:"body:ionMenuChange",method:"updateVisibility"},{name:"body:ionSplitPaneVisible",method:"updateVisibility"}]},enumerable:!0,configurable:!0}),Object.defineProperty(t,"style",{get:function(){return":host(.menu-toggle-hidden){display:none}"},enumerable:!0,configurable:!0}),t}();function h(t){var e=t.querySelector("ion-menu-controller");return e?e.componentOnReady():Promise.resolve(void 0)}e.IonMenu=o,e.IonMenuButton=l,e.IonMenuToggle=c,Object.defineProperty(e,"__esModule",{value:!0})});                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 'use strict';

var typeOf = require('kind-of');
var utils = module.exports;

/**
 * Returns true if the given value is a node.
 *
 * ```js
 * var Node = require('snapdragon-node');
 * var node = new Node({type: 'foo'});
 * console.log(utils.isNode(node)); //=> true
 * console.log(utils.isNode({})); //=> false
 * ```
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @returns {Boolean}
 * @api public
 */

utils.isNode = function(node) {
  return typeOf(node) === 'object' && node.isNode === true;
};

/**
 * Emit an empty string for the given `node`.
 *
 * ```js
 * // do nothing for beginning-of-string
 * snapdragon.compiler.set('bos', utils.noop);
 * ```
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @returns {undefined}
 * @api public
 */

utils.noop = function(node) {
  append(this, '', node);
};

/**
 * Appdend `node.val` to `compiler.output`, exactly as it was created
 * by the parser.
 *
 * ```js
 * snapdragon.compiler.set('text', utils.identity);
 * ```
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @returns {undefined}
 * @api public
 */

utils.identity = function(node) {
  append(this, node.val, node);
};

/**
 * Previously named `.emit`, this method appends the given `val`
 * to `compiler.output` for the given node. Useful when you know
 * what value should be appended advance, regardless of the actual
 * value of `node.val`.
 *
 * ```js
 * snapdragon.compiler
 *   .set('i', function(node) {
 *     this.mapVisit(node);
 *   })
 *   .set('i.open', utils.append('<i>'))
 *   .set('i.close', utils.append('</i>'))
 * ```
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @returns {Function} Returns a compiler middleware function.
 * @api public
 */

utils.append = function(val) {
  return function(node) {
    append(this, val, node);
  };
};

/**
 * Used in compiler middleware, this onverts an AST node into
 * an empty `text` node and deletes `node.nodes` if it exists.
 * The advantage of this method is that, as opposed to completely
 * removing the node, indices will not need to be re-calculated
 * in sibling nodes, and nothing is appended to the output.
 *
 * ```js
 * utils.toNoop(node);
 * // convert `node.nodes` to the given value instead of deleting it
 * utils.toNoop(node, []);
 * ```
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @param {Array} `nodes` Optionally pass a new `nodes` value, to replace the existing `node.nodes` array.
 * @api public
 */

utils.toNoop = function(node, nodes) {
  if (nodes) {
    node.nodes = nodes;
  } else {
    delete node.nodes;
    node.type = 'text';
    node.val = '';
  }
};

/**
 * Visit `node` with the given `fn`. The built-in `.visit` method in snapdragon
 * automatically calls registered compilers, this allows you to pass a visitor
 * function.
 *
 * ```js
 * snapdragon.compiler.set('i', function(node) {
 *   utils.visit(node, function(childNode) {
 *     // do stuff with "childNode"
 *     return childNode;
 *   });
 * });
 * ```
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @param {Function} `fn`
 * @return {Object} returns the node after recursively visiting all child nodes.
 * @api public
 */

utils.visit = function(node, fn) {
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  assert(isFunction(fn), 'expected a visitor function');
  fn(node);
  return node.nodes ? utils.mapVisit(node, fn) : node;
};

/**
 * Map [visit](#visit) the given `fn` over `node.nodes`. This is called by
 * [visit](#visit), use this method if you do not want `fn` to be called on
 * the first node.
 *
 * ```js
 * snapdragon.compiler.set('i', function(node) {
 *   utils.mapVisit(node, function(childNode) {
 *     // do stuff with "childNode"
 *     return childNode;
 *   });
 * });
 * ```
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @param {Object} `options`
 * @param {Function} `fn`
 * @return {Object} returns the node
 * @api public
 */

utils.mapVisit = function(node, fn) {
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  assert(isArray(node.nodes), 'expected node.nodes to be an array');
  assert(isFunction(fn), 'expected a visitor function');

  for (var i = 0; i < node.nodes.length; i++) {
    utils.visit(node.nodes[i], fn);
  }
  return node;
};

/**
 * Unshift an `*.open` node onto `node.nodes`.
 *
 * ```js
 * var Node = require('snapdragon-node');
 * snapdragon.parser.set('brace', function(node) {
 *   var match = this.match(/^{/);
 *   if (match) {
 *     var parent = new Node({type: 'brace'});
 *     utils.addOpen(parent, Node);
 *     console.log(parent.nodes[0]):
 *     // { type: 'brace.open', val: '' };
 *
 *     // push the parent "brace" node onto the stack
 *     this.push(parent);
 *
 *     // return the parent node, so it's also added to the AST
 *     return brace;
 *   }
 * });
 * ```
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @param {Function} `Node` (required) Node constructor function from [snapdragon-node][].
 * @param {Function} `filter` Optionaly specify a filter function to exclude the node.
 * @return {Object} Returns the created opening node.
 * @api public
 */

utils.addOpen = function(node, Node, val, filter) {
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  assert(isFunction(Node), 'expected Node to be a constructor function');

  if (typeof val === 'function') {
    filter = val;
    val = '';
  }

  if (typeof filter === 'function' && !filter(node)) return;
  var open = new Node({ type: node.type + '.open', val: val});
  var unshift = node.unshift || node.unshiftNode;
  if (typeof unshift === 'function') {
    unshift.call(node, open);
  } else {
    utils.unshiftNode(node, open);
  }
  return open;
};

/**
 * Push a `*.close` node onto `node.nodes`.
 *
 * ```js
 * var Node = require('snapdragon-node');
 * snapdragon.parser.set('brace', function(node) {
 *   var match = this.match(/^}/);
 *   if (match) {
 *     var parent = this.parent();
 *     if (parent.type !== 'brace') {
 *       throw new Error('missing opening: ' + '}');
 *     }
 *
 *     utils.addClose(parent, Node);
 *     console.log(parent.nodes[parent.nodes.length - 1]):
 *     // { type: 'brace.close', val: '' };
 *
 *     // no need to return a node, since the parent
 *     // was already added to the AST
 *     return;
 *   }
 * });
 * ```
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @param {Function} `Node` (required) Node constructor function from [snapdragon-node][].
 * @param {Function} `filter` Optionaly specify a filter function to exclude the node.
 * @return {Object} Returns the created closing node.
 * @api public
 */

utils.addClose = function(node, Node, val, filter) {
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  assert(isFunction(Node), 'expected Node to be a constructor function');

  if (typeof val === 'function') {
    filter = val;
    val = '';
  }

  if (typeof filter === 'function' && !filter(node)) return;
  var close = new Node({ type: node.type + '.close', val: val});
  var push = node.push || node.pushNode;
  if (typeof push === 'function') {
    push.call(node, close);
  } else {
    utils.pushNode(node, close);
  }
  return close;
};

/**
 * Wraps the given `node` with `*.open` and `*.close` nodes.
 *
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @param {Function} `Node` (required) Node constructor function from [snapdragon-node][].
 * @param {Function} `filter` Optionaly specify a filter function to exclude the node.
 * @return {Object} Returns the node
 * @api public
 */

utils.wrapNodes = function(node, Node, filter) {
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  assert(isFunction(Node), 'expected Node to be a constructor function');

  utils.addOpen(node, Node, filter);
  utils.addClose(node, Node, filter);
  return node;
};

/**
 * Push the given `node` onto `parent.nodes`, and set `parent` as `node.parent.
 *
 * ```js
 * var parent = new Node({type: 'foo'});
 * var node = new Node({type: 'bar'});
 * utils.pushNode(parent, node);
 * console.log(parent.nodes[0].type) // 'bar'
 * console.log(node.parent.type) // 'foo'
 * ```
 * @param {Object} `parent`
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @return {Object} Returns the child node
 * @api public
 */

utils.pushNode = function(parent, node) {
  assert(utils.isNode(parent), 'expected parent node to be an instance of Node');
  assert(utils.isNode(node), 'expected node to be an instance of Node');

  node.define('parent', parent);
  parent.nodes = parent.nodes || [];
  parent.nodes.push(node);
  return node;
};

/**
 * Unshift `node` onto `parent.nodes`, and set `parent` as `node.parent.
 *
 * ```js
 * var parent = new Node({type: 'foo'});
 * var node = new Node({type: 'bar'});
 * utils.unshiftNode(parent, node);
 * console.log(parent.nodes[0].type) // 'bar'
 * console.log(node.parent.type) // 'foo'
 * ```
 * @param {Object} `parent`
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @return {undefined}
 * @api public
 */

utils.unshiftNode = function(parent, node) {
  assert(utils.isNode(parent), 'expected parent node to be an instance of Node');
  assert(utils.isNode(node), 'expected node to be an instance of Node');

  node.define('parent', parent);
  parent.nodes = parent.nodes || [];
  parent.nodes.unshift(node);
};

/**
 * Pop the last `node` off of `parent.nodes`. The advantage of
 * using this method is that it checks for `node.nodes` and works
 * with any version of `snapdragon-node`.
 *
 * ```js
 * var parent = new Node({type: 'foo'});
 * utils.pushNode(parent, new Node({type: 'foo'}));
 * utils.pushNode(parent, new Node({type: 'bar'}));
 * utils.pushNode(parent, new Node({type: 'baz'}));
 * console.log(parent.nodes.length); //=> 3
 * utils.popNode(parent);
 * console.log(parent.nodes.length); //=> 2
 * ```
 * @param {Object} `parent`
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @return {Number|Undefined} Returns the length of `node.nodes` or undefined.
 * @api public
 */

utils.popNode = function(node) {
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  if (typeof node.pop === 'function') {
    return node.pop();
  }
  return node.nodes && node.nodes.pop();
};

/**
 * Shift the first `node` off of `parent.nodes`. The advantage of
 * using this method is that it checks for `node.nodes` and works
 * with any version of `snapdragon-node`.
 *
 * ```js
 * var parent = new Node({type: 'foo'});
 * utils.pushNode(parent, new Node({type: 'foo'}));
 * utils.pushNode(parent, new Node({type: 'bar'}));
 * utils.pushNode(parent, new Node({type: 'baz'}));
 * console.log(parent.nodes.length); //=> 3
 * utils.shiftNode(parent);
 * console.log(parent.nodes.length); //=> 2
 * ```
 * @param {Object} `parent`
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @return {Number|Undefined} Returns the length of `node.nodes` or undefined.
 * @api public
 */

utils.shiftNode = function(node) {
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  if (typeof node.shift === 'function') {
    return node.shift();
  }
  return node.nodes && node.nodes.shift();
};

/**
 * Remove the specified `node` from `parent.nodes`.
 *
 * ```js
 * var parent = new Node({type: 'abc'});
 * var foo = new Node({type: 'foo'});
 * utils.pushNode(parent, foo);
 * utils.pushNode(parent, new Node({type: 'bar'}));
 * utils.pushNode(parent, new Node({type: 'baz'}));
 * console.log(parent.nodes.length); //=> 3
 * utils.removeNode(parent, foo);
 * console.log(parent.nodes.length); //=> 2
 * ```
 * @param {Object} `parent`
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @return {Object|undefined} Returns the removed node, if successful, or undefined if it does not exist on `parent.nodes`.
 * @api public
 */

utils.removeNode = function(parent, node) {
  assert(utils.isNode(parent), 'expected parent.node to be an instance of Node');
  assert(utils.isNode(node), 'expected node to be an instance of Node');

  if (!parent.nodes) {
    return null;
  }

  if (typeof parent.remove === 'function') {
    return parent.remove(node);
  }

  var idx = parent.nodes.indexOf(node);
  if (idx !== -1) {
    return parent.nodes.splice(idx, 1);
  }
};

/**
 * Returns true if `node.type` matches the given `type`. Throws a
 * `TypeError` if `node` is not an instance of `Node`.
 *
 * ```js
 * var Node = require('snapdragon-node');
 * var node = new Node({type: 'foo'});
 * console.log(utils.isType(node, 'foo')); // false
 * console.log(utils.isType(node, 'bar')); // true
 * ```
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @param {String} `type`
 * @return {Boolean}
 * @api public
 */

utils.isType = function(node, type) {
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  switch (typeOf(type)) {
    case 'array':
      var types = type.slice();
      for (var i = 0; i < types.length; i++) {
        if (utils.isType(node, types[i])) {
          return true;
        }
      }
      return false;
    case 'string':
      return node.type === type;
    case 'regexp':
      return type.test(node.type);
    default: {
      throw new TypeError('expected "type" to be an array, string or regexp');
    }
  }
};

/**
 * Returns true if the given `node` has the given `type` in `node.nodes`.
 * Throws a `TypeError` if `node` is not an instance of `Node`.
 *
 * ```js
 * var Node = require('snapdragon-node');
 * var node = new Node({
 *   type: 'foo',
 *   nodes: [
 *     new Node({type: 'bar'}),
 *     new Node({type: 'baz'})
 *   ]
 * });
 * console.log(utils.hasType(node, 'xyz')); // false
 * console.log(utils.hasType(node, 'baz')); // true
 * ```
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @param {String} `type`
 * @return {Boolean}
 * @api public
 */

utils.hasType = function(node, type) {
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  if (!Array.isArray(node.nodes)) return false;
  for (var i = 0; i < node.nodes.length; i++) {
    if (utils.isType(node.nodes[i], type)) {
      return true;
    }
  }
  return false;
};

/**
 * Returns the first node from `node.nodes` of the given `type`
 *
 * ```js
 * var node = new Node({
 *   type: 'foo',
 *   nodes: [
 *     new Node({type: 'text', val: 'abc'}),
 *     new Node({type: 'text', val: 'xyz'})
 *   ]
 * });
 *
 * var textNode = utils.firstOfType(node.nodes, 'text');
 * console.log(textNode.val);
 * //=> 'abc'
 * ```
 * @param {Array} `nodes`
 * @param {String} `type`
 * @return {Object|undefined} Returns the first matching node or undefined.
 * @api public
 */

utils.firstOfType = function(nodes, type) {
  for (var i = 0; i < nodes.length; i++) {
    var node = nodes[i];
    if (utils.isType(node, type)) {
      return node;
    }
  }
};

/**
 * Returns the node at the specified index, or the first node of the
 * given `type` from `node.nodes`.
 *
 * ```js
 * var node = new Node({
 *   type: 'foo',
 *   nodes: [
 *     new Node({type: 'text', val: 'abc'}),
 *     new Node({type: 'text', val: 'xyz'})
 *   ]
 * });
 *
 * var nodeOne = utils.findNode(node.nodes, 'text');
 * console.log(nodeOne.val);
 * //=> 'abc'
 *
 * var nodeTwo = utils.findNode(node.nodes, 1);
 * console.log(nodeTwo.val);
 * //=> 'xyz'
 * ```
 *
 * @param {Array} `nodes`
 * @param {String|Number} `type` Node type or index.
 * @return {Object} Returns a node or undefined.
 * @api public
 */

utils.findNode = function(nodes, type) {
  if (!Array.isArray(nodes)) {
    return null;
  }
  if (typeof type === 'number') {
    return nodes[type];
  }
  return utils.firstOfType(nodes, type);
};

/**
 * Returns true if the given node is an "*.open" node.
 *
 * ```js
 * var Node = require('snapdragon-node');
 * var brace = new Node({type: 'brace'});
 * var open = new Node({type: 'brace.open'});
 * var close = new Node({type: 'brace.close'});
 *
 * console.log(utils.isOpen(brace)); // false
 * console.log(utils.isOpen(open)); // true
 * console.log(utils.isOpen(close)); // false
 * ```
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @return {Boolean}
 * @api public
 */

utils.isOpen = function(node) {
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  return node.type.slice(-5) === '.open';
};

/**
 * Returns true if the given node is a "*.close" node.
 *
 * ```js
 * var Node = require('snapdragon-node');
 * var brace = new Node({type: 'brace'});
 * var open = new Node({type: 'brace.open'});
 * var close = new Node({type: 'brace.close'});
 *
 * console.log(utils.isClose(brace)); // false
 * console.log(utils.isClose(open)); // false
 * console.log(utils.isClose(close)); // true
 * ```
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @return {Boolean}
 * @api public
 */

utils.isClose = function(node) {
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  return node.type.slice(-6) === '.close';
};

/**
 * Returns true if `node.nodes` **has** an `.open` node
 *
 * ```js
 * var Node = require('snapdragon-node');
 * var brace = new Node({
 *   type: 'brace',
 *   nodes: []
 * });
 *
 * var open = new Node({type: 'brace.open'});
 * console.log(utils.hasOpen(brace)); // false
 *
 * brace.pushNode(open);
 * console.log(utils.hasOpen(brace)); // true
 * ```
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @return {Boolean}
 * @api public
 */

utils.hasOpen = function(node) {
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  var first = node.first || node.nodes ? node.nodes[0] : null;
  if (utils.isNode(first)) {
    return first.type === node.type + '.open';
  }
  return false;
};

/**
 * Returns true if `node.nodes` **has** a `.close` node
 *
 * ```js
 * var Node = require('snapdragon-node');
 * var brace = new Node({
 *   type: 'brace',
 *   nodes: []
 * });
 *
 * var close = new Node({type: 'brace.close'});
 * console.log(utils.hasClose(brace)); // false
 *
 * brace.pushNode(close);
 * console.log(utils.hasClose(brace)); // true
 * ```
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @return {Boolean}
 * @api public
 */

utils.hasClose = function(node) {
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  var last = node.last || node.nodes ? node.nodes[node.nodes.length - 1] : null;
  if (utils.isNode(last)) {
    return last.type === node.type + '.close';
  }
  return false;
};

/**
 * Returns true if `node.nodes` has both `.open` and `.close` nodes
 *
 * ```js
 * var Node = require('snapdragon-node');
 * var brace = new Node({
 *   type: 'brace',
 *   nodes: []
 * });
 *
 * var open = new Node({type: 'brace.open'});
 * var close = new Node({type: 'brace.close'});
 * console.log(utils.hasOpen(brace)); // false
 * console.log(utils.hasClose(brace)); // false
 *
 * brace.pushNode(open);
 * brace.pushNode(close);
 * console.log(utils.hasOpen(brace)); // true
 * console.log(utils.hasClose(brace)); // true
 * ```
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @return {Boolean}
 * @api public
 */

utils.hasOpenAndClose = function(node) {
  return utils.hasOpen(node) && utils.hasClose(node);
};

/**
 * Push the given `node` onto the `state.inside` array for the
 * given type. This array is used as a specialized "stack" for
 * only the given `node.type`.
 *
 * ```js
 * var state = { inside: {}};
 * var node = new Node({type: 'brace'});
 * utils.addType(state, node);
 * console.log(state.inside);
 * //=> { brace: [{type: 'brace'}] }
 * ```
 * @param {Object} `state` The `compiler.state` object or custom state object.
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @return {Array} Returns the `state.inside` stack for the given type.
 * @api public
 */

utils.addType = function(state, node) {
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  assert(isObject(state), 'expected state to be an object');

  var type = node.parent
    ? node.parent.type
    : node.type.replace(/\.open$/, '');

  if (!state.hasOwnProperty('inside')) {
    state.inside = {};
  }
  if (!state.inside.hasOwnProperty(type)) {
    state.inside[type] = [];
  }

  var arr = state.inside[type];
  arr.push(node);
  return arr;
};

/**
 * Remove the given `node` from the `state.inside` array for the
 * given type. This array is used as a specialized "stack" for
 * only the given `node.type`.
 *
 * ```js
 * var state = { inside: {}};
 * var node = new Node({type: 'brace'});
 * utils.addType(state, node);
 * console.log(state.inside);
 * //=> { brace: [{type: 'brace'}] }
 * utils.removeType(state, node);
 * //=> { brace: [] }
 * ```
 * @param {Object} `state` The `compiler.state` object or custom state object.
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @return {Array} Returns the `state.inside` stack for the given type.
 * @api public
 */

utils.removeType = function(state, node) {
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  assert(isObject(state), 'expected state to be an object');

  var type = node.parent
    ? node.parent.type
    : node.type.replace(/\.close$/, '');

  if (state.inside.hasOwnProperty(type)) {
    return state.inside[type].pop();
  }
};

/**
 * Returns true if `node.val` is an empty string, or `node.nodes` does
 * not contain any non-empty text nodes.
 *
 * ```js
 * var node = new Node({type: 'text'});
 * utils.isEmpty(node); //=> true
 * node.val = 'foo';
 * utils.isEmpty(node); //=> false
 * ```
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @param {Function} `fn`
 * @return {Boolean}
 * @api public
 */

utils.isEmpty = function(node, fn) {
  assert(utils.isNode(node), 'expected node to be an instance of Node');

  if (!Array.isArray(node.nodes)) {
    if (node.type !== 'text') {
      return true;
    }
    if (typeof fn === 'function') {
      return fn(node, node.parent);
    }
    return !utils.trim(node.val);
  }

  for (var i = 0; i < node.nodes.length; i++) {
    var child = node.nodes[i];
    if (utils.isOpen(child) || utils.isClose(child)) {
      continue;
    }
    if (!utils.isEmpty(child, fn)) {
      return false;
    }
  }

  return true;
};

/**
 * Returns true if the `state.inside` stack for the given type exists
 * and has one or more nodes on it.
 *
 * ```js
 * var state = { inside: {}};
 * var node = new Node({type: 'brace'});
 * console.log(utils.isInsideType(state, 'brace')); //=> false
 * utils.addType(state, node);
 * console.log(utils.isInsideType(state, 'brace')); //=> true
 * utils.removeType(state, node);
 * console.log(utils.isInsideType(state, 'brace')); //=> false
 * ```
 * @param {Object} `state`
 * @param {String} `type`
 * @return {Boolean}
 * @api public
 */

utils.isInsideType = function(state, type) {
  assert(isObject(state), 'expected state to be an object');
  assert(isString(type), 'expected type to be a string');

  if (!state.hasOwnProperty('inside')) {
    return false;
  }

  if (!state.inside.hasOwnProperty(type)) {
    return false;
  }

  return state.inside[type].length > 0;
};

/**
 * Returns true if `node` is either a child or grand-child of the given `type`,
 * or `state.inside[type]` is a non-empty array.
 *
 * ```js
 * var state = { inside: {}};
 * var node = new Node({type: 'brace'});
 * var open = new Node({type: 'brace.open'});
 * console.log(utils.isInside(state, open, 'brace')); //=> false
 * utils.pushNode(node, open);
 * console.log(utils.isInside(state, open, 'brace')); //=> true
 * ```
 * @param {Object} `state` Either the `compiler.state` object, if it exists, or a user-supplied state object.
 * @param {Object} `node` Instance of [snapdragon-node][]
 * @param {String} `type` The `node.type` to check for.
 * @return {Boolean}
 * @api public
 */

utils.isInside = function(state, node, type) {
  assert(utils.isNode(node), 'expected node to be an instance of Node');
  assert(isObject(state), 'expected state to be an object');

  if (Array.isArray(type)) {
    for (var i = 0; i < type.length; i++) {
      if (utils.isInside(state, node, type[i])) {
        return true;
      }
    }
    return false;
  }

  var parent = node.parent;
  if (typeof type === 'string') {
    return (parent && parent.type === type) || utils.isInsideType(state, type);
  }

  if (typeOf(type) === 'regexp') {
    if (parent && parent.type && type.test(parent.type)) {
      return true;
    }

    var keys = Object.keys(state.inside);
    var len = keys.length;
    var idx = -1;
    while (++idx < len) {
      var key = keys[idx];
      var val = state.inside[key];

      if (Array.isArray(val) && val.length !== 0 && type.test(key)) {
        return true;
      }
    }
  }
  return false;
};

/**
 * Get the last `n` element from the given `array`. Used for getting
 * a node from `node.nodes.`
 *
 * @param {Array} `array`
 * @param {Number} `n`
 * @return {undefined}
 * @api public
 */

utils.last = function(arr, n) {
  return arr[arr.length - (n || 1)];
};

/**
 * Cast the given `val` to an array.
 *
 * ```js
 * console.log(utils.arrayify(''));
 * //=> []
 * console.log(utils.arrayify('foo'));
 * //=> ['foo']
 * console.log(utils.arrayify(['foo']));
 * //=> ['foo']
 * ```
 * @param {any} `val`
 * @return {Array}
 * @api public
 */

utils.arrayify = function(val) {
  if (typeof val === 'string' && val !== '') {
    return [val];
  }
  if (!Array.isArray(val)) {
    return [];
  }
  return val;
};

/**
 * Convert the given `val` to a string by joining with `,`. Useful
 * for creating a cheerio/CSS/DOM-style selector from a list of strings.
 *
 * @param {any} `val`
 * @return {Array}
 * @api public
 */

utils.stringify = function(val) {
  return utils.arrayify(val).join(',');
};

/**
 * Ensure that the given value is a string and call `.trim()` on it,
 * or return an empty string.
 *
 * @param {String} `str`
 * @return {String}
 * @api public
 */

utils.trim = function(str) {
  return typeof str === 'string' ? str.trim() : '';
};

/**
 * Return true if val is an object
 */

function isObject(val) {
  return typeOf(val) === 'object';
}

/**
 * Return true if val is a string
 */

function isString(val) {
  return typeof val === 'string';
}

/**
 * Return true if val is a function
 */

function isFunction(val) {
  return typeof val === 'function';
}

/**
 * Return true if val is an array
 */

function isArray(val) {
  return Array.isArray(val);
}

/**
 * Shim to ensure the `.append` methods work with any version of snapdragon
 */

function append(compiler, val, node) {
  if (typeof compiler.append !== 'function') {
    return compiler.emit(val, node);
  }
  return compiler.append(val, node);
}

/**
 * Simplified assertion. Throws an error is `val` is falsey.
 */

function assert(val, message) {
  if (!val) throw new Error(message);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               QHBKE xú¨wTúÕ≤- xpó‡ÉÓwww∑‡n!∏Ö‡Ó‹›apwww}$ˇπÁ?Ô<ªÔÆ;”´æÍ]›]ª∫Î´È!ó•“≥"íoléO!¬ââÌ-yxî›?õ0»ò˝&∂NƒL,oFE!;[ß∑Æ#1ê˘O_∆ƒÿ¬@–ŒMãÒ≠Àd"fÁd“a∞µµsr‘b˙=Ñ¯œD1;Áœƒlf)9989˝µ≤#1#É≤Å°#ÉÉ¢â£ù≥Éëâ„y;#%'-Ü7é &nN:"nNbJNN&of1%vbˆ?kâ)YZXÀ~6ïr!Ê¯Ò1àæë|#
$Ê¸3DTYA@DC ^Aí»Ù◊òﬂD[„ﬂ·2˝[ÿÿ3(9:˝Ó©Yõô8Ωq3r“2q“≥≥qÈ9ôàô89Ë9àŸÅ¨Ùlo!ÀøMó%f˛a*qÎ7NÙl,ƒ ¶o∞ÄAîòÂçÉ≤É<15e*[ É1„ﬂÑòˇçê∫ú°Âõ˚Rµs∞a¸è]≤q“9999àôòÈŸŸÅ:“&∂fNÊø◊ttr01∞AÑÉ{[˚?Ù∏a˘œ«Õ§gd!fce˛˝`‚d•g"fcgßge˙g‡¨ˇﬂÅ€ºùíπµªÉâ˝øÖœ˙ˇ>=-Í∑a°g·`dd˘OÜœˆ∑%e[«œø“»ùAHâAÿƒ≈¬»DQLoZÏˇFÎüÈ» (√ ˚∆…¿ö¡»Ä¯˜éˇ˜åøs˛€‡ﬂI¸œêïúM˛†Çé&,ÇB¬""4B÷Ü¢éNBÊƒÃL“Î≤oÈıˆ&0àÿŸ[ÿöΩù´≠Ä≠£≈?˚øW6q4r∞¯ÏdÁ@d¸s<oßÔd˛ˆ3±È¸MÒèÌﬂ9˛=˜O˜èø'˜Ü´ôXòô;≥022àZò9˛Êˆˇsét¨åÃƒtL¨oß…ƒ¬HÃŒ ¯ñWéFøÎŒõŒ dY¸ØÈø{ø˛∂¸ˇVILlTâYô$úﬁú	ÿöYõº≥?ºYÄ2nuÄÏ,ÃÍˇXÍ˜ÏﬂD-¨MòàÅ¿øÚ˜ü°˛K-¸+õÄø_4v∂∑≠∂v2q¯Öìâ∞…€.ö¸Gæ±≥3≤≥ˇùsniG:∞nqøö¯v3Ω•(>¬¬Bé}˝$ÿm´˛’ﬂ˙H[ÏcÏ Œ‡é± ò i„DHXKë t±ävP˘	ïmùm]Ωf¶÷¢%FâÛëè∑ºØÏîÔ¥	O=≠<O”2]WnΩvπW}o“jI«∞•˙É3ËËÀ“îŒMv{í´Ì—å mLj$1"%€#´¬ã±7Â‚GSÙTåö™‡/±ï˙î„‚_›_)ıÄ&À.}ND™¥∫ 8≈©ÕÅUR }Uj ¶º˜3D…ä ùÍ†ëxëÕóÛ±ÁCîC÷÷:äâ#;©õŒ«à»íïegVèk4fóüH}áã∏)¸Ø^˛ÈU
Œ–¨wããs˙;]èÃ
´ÛµŸÌk∑ôz›s≈ãÎØFz∑Öi§î$/‘qrñ_ªÏÉœù∑D|‹åçΩg0ó—[Kí™“ú≠÷1˘"2{‘gô©∆≠-Ô∞2j◊çÍt"ÈÏn*ÏÜ	yÒm÷y©‘¥ûFªñú•¯_¡˚æ3-h.í∂—=`y}ZÏÓ™Øsàa„E?Ù§KGî≠/dl?∂‡Õê…=Fò$'ã#∑wÏsv…!µ8l&#eö›w:1Tc0Jôãa˚v7ªhMê\K5ßwÁâ†3ÑÕb§§1ËStYkK	ÁÀ<˝Ùcæräëc0Í°Æ·.’»Húq@ïGzéo*†M◊≈≥b"*æx®ıCKbÅUº∂ÙÆ≥Êƒ#ÇDNaHÜS-Îì»Õ+éûI√ÎÑçxûCG¬ö˙(ÚrêC&Â∂F˝e∞≠	π‚üˆ≥É†Êx¯f|≠ÕK{Ã^¸&˜mW≤Õ–˝ò¢Hí£W÷ú≤<\eΩ]AUP•HÑ-ûõòuôÅ∑>}Íß´Ûm^ÚvƒÑ£+Ø2ÕMÕ4I1æY€||/ZÊ4Áß•Ä£¥S¨S_“¯◊¥˚¨S™≈~õ°é˝óì/j™ﬂrlGb’ ¥t∂µTõú7D‡±F2Ÿ]«é¬.™~◊`nc.»‰∞9àQJß®+s43∞õ5ö%q3”Åíè*5ËLc'≥fiqÓCV”Ê∂2 ôá…ºûµûOåwè8ñ9‘“€˝¬øpGexg¶‡«6y⁄∂ˆè/∑dùqSŸö?—]MÓJÒZ"ÎUÂ¡=<) ’·ÚÌC•ÃÏZ‚¿0Õœe'ò∞%+ËÊ&àœ≤∫$˛ä#Y!L≠ÎUB≠ç¢◊˜,e«Sfü™ﬁïŸMëø*8RHöˇ®ã˜k;Ó˛0'<Q9>æπ∫¶Ñèf“P$í\!S
1î≠ÊröÍ±π·ñC√F¶ΩmLiWO„◊Ω¬-µôeo[r~ÆüJ∏MÁÈ“Núÿtgq	"óºÔŸÏ,V·›¶øm^-gYVœåË^AIõO∞ÄÊ9vi™ƒîlÛèâÈt∫—âøH–é5E‹„5éh≈È®X
Úi|?A#◊©Œ´à§‘íV—êyoÓ1W+„jÀ≠xÏ"ä+Q–±ï±…R®‰ü;–Â€k©b\'∫=ü∑'„(ΩÛıE‰BAÌ©Ã£÷‹≤/p7çÅD(N
ê7âW%◊•KQE5aıw+3W–¯aû®9££$âà^≈#U|b∂Èâ|îú’|eÜ¶^g.∆í˚.ˆª÷åéäëÛl„A%ﬂ·/j5ói≠»ıíe®≠{⁄dÃY≥ıq§&›’1á›>≠áÌ∞D%LJçŒ∫ü(CcJ~≠◊…Bò[SCe	îá∑Çz˚· âc`œA“4ú$ΩHìi1^']fü;e+¨aÎm¯ˆ◊Ï
ô´;\˜pËHÂ·/˘œ∏n“ÚB≠˛ÁÊ´K≤""O†"Ã)N-Ã}áJG•¢Ã°# π÷Uö€∞≈ºÍB+ ï;√“∫˚tµ˝‰cëx∂≈sïÍ£$¸x,%˙°jZfIÿ}˜v)ŸíÑäâÔ˘˘~åÒêe√<sEµ÷ª€^H&Ó˜Èl;cÁôji\‡Z5¯Ö©ÖKß
ÈñÓÖ%ıû—≥ãÀ™™S"Ωg#?oîUe-lt4ÎÊÎZ©„G7/Fqu¸jÃfëWÎç£ÌJ¥ú;bÅŒã’≈I›ÒﬂS4~yÂñ¯ƒ+LUæ™`ãàb‡†X òLGWù;´ËÀî+pjΩ≤ÇôGMÿ∆ x·Ê”~tP¶™’Ñ~ï≤Ó˝∞ŸHßtÿ{e]l{T˛35‹Dü˙<X¨…å+ú:cﬂ≥—∞V¨,c≠¥hîYjŒÏ˝#B5^‡Ú◊¿.fh±4âeV¬4%uyïê‡@XºÆ∞¡UCÂÊ≤<‡◊º∫eâÜäÇﬂòè–òˆù ˚ÈNmîc∏;Ó§
…i÷ÌXe£˘!øœ…huƒ_»	¡	∑5	™ ~M]Ô,Ø[æÖ∫®àï\Ç§J-8∏àŒ[è£KsÉX∂¬∞0T\=˙,<—¥∫RÀâ·˙®K61J
òÊ'/¸`D¸q1rÀÃ¸%iùπ§ Ë´ﬂŸì8‡ññª}D[˛π=á?Sîˇ¸\Ã\+{Ó{æí3+´Óp:ûkgK∫ûf‹¢’&#U
È¬˛›ú›◊@S	d≠çËXÕpcA˚ÈÊ˛ËûÃÉE˝sÙ·!S{—π`qâƒ’Rî˝Ï6Ì·~®ÊcãÆŒ
?~o∑q˘cU•ÜÛÌy–ﬁ–”$‘Œf“Ë“≤çãó#.CMnt†]èbü!f˙BnösyÏx‡50ó#∆ú«°6™h˝}É¿&Y%v≠Ë$Y%Ü Q¨ï≤/F∑Q¨ïú$©AóQ,çﬂ@*≤HNã¥° Úﬁã+–ÍÖ·fƒ´4√bÛ’…Aí Uq:ëxtJâ*m∏LÙ·º¢8√ËRyÍ¥  ¶d’ß∞{≈ëX√rt«º$:ë@Ùm≈8	jëPÙöº$@†Zé¢t‚Ü0†@®PîN»QCÀK"	(ƒÅ∫aˆäÒÜË"äËí@Õ0¿E>69Hpëá˝Q§ùS!±õƒ®Œóœˇ,T˚®àê–M"TÁƒf°„(ÊI≈PÄ¿ ä˘‚1› ëjt	EéºJ)ÉÿnÍ@∏t
@Ñ"vﬁÑTv¨`Ã©Æç/∑íˆ¬a=ä^‰†DE¸ÔDä^A´˘w⁄a„yw aryw©ËDRÁ1ËæÒB $…sÙS©s,¿JÏÜ‡Öîôwóã~*~a -*‚€pUl%•*>©Ü±ÁπÈÑ≠äüß†WHû[|»A4äOäaâ˘wÅËÁ9Ë‚Á≠Ë„ÁéÄå¯3ER–î"9(VëÁ#»@ò∏‹Hú°GãüW¢#Kúg°#ã€w†Û*.QÇ⁄óHAÀäGÒ$ B@é‚9(]qÈ#ËXÒ(aÉ`øQ®∏DU\"…Â5*Ñ·Â5ÍÜÈ(jSÇÍü‘√¨Ú5√JÚÊ †xEÌè†mEm
Pæ¢6	§®MB–«m@ ∆[–w%&È@—ys†&≈4R–º‚Är‚,!}Ø∂ÆgcÎÕg˜„ıãÖûÌ∫‡·ˇªÅ0Ap≈∑±ıı≥˚Î˙≈Kœˆs#r‚-˝)øˆ£·oﬂı=€6¡√ãHâÙv‹⁄+.ç≠«ü›§n‡¸µ≠˜úÿOF™≤˜≥Ë‚∏ôŸú‡ä¬Ã>§‚Y¬ÿ,Q‰LÖ∞°⁄Ñ &√j·)BêiäMò†’°∫YZ– „)–(¿7±†±¢îE"“C¶¢ìXíYG#“CA‘ƒ–âã…/–~}(˚®)s-[∞Dù/LRZ"K¢)ªE™)™,Qg;iò#"ä˘aî2EåÖ}'2EàÖ{'æòò:∫i«»∞¸>K15GCô-ˆ¿=‘Tæm_òUÜt¸á∞R—ÉqéaZäLû>ZHüRúΩ∞Qhü|%Ié`1{JëU¶9˙§xO
:W"U∞!Â≈ƒ‹âyaÍ_éhà‰∏Ç,I",TlÊ©¬©òŸÃQÃâ†q¶Bp¯Q≈S•	Kì8|òˇ1"jL^-üú< laBçc®!ı…ÉÑ c»û§ Âîú+ßÈ¨'Ó1lO*GH˘y»[‡ 5g<î/‹Ñ“w∏Ùù∑`Sä∑ÙJ¸sº*ŸÉﬂ–
Â<Œ*©G‚ﬁ∏∞/I"ø‚	¡–≥øC•GÍX¸s‘SªƒïV{à.e‚™¸	kéö§ƒ3€gŒ=5·äoÁâ¬hœ_ˆ»‹cˆ†ò¯‰Æ'«C3»3QxÖ˙
C3H<æÔ¡Ê<o›slí.à]Q≈Û
^1‚ëx|€œyı∏‰ZñrBû\ˆ4¬a˛T•ﬁ'9AòC5©#Ïä∫,‡ƒ=iõ≥hà√Qq_Üæ](‹ ??*ÃéÚ¸uO4/§úrAƒâ ™%!Á)ió∫%eè:']XM1êÜ ïs“D8Qqû}€0'º»f2PÎC∫\m:œxÆ6˚dtH=J∫îì,Ì22wÇ.<W∏πmam‡ﬁàz3Ú4ÜTø¡»xHæD∫lmr±]éG!äMD˛¨?õ¸ıµp∫aWâ1:óÙ/9rÀ|òOeË•Å<©°)!3®oŸò„)å8]ÌQLHVL:¶@ìYdé8iyp58]≠"LÛcäÜ âµ≠(lèÃÚƒ¡#&:áñ¥òLS≤ñ,aä.*?îù6,?tªç1°£ñ8Åó%S{e42]∑sWﬁñM
gÿ»¢0`»–b˜ã§ëÖôü§°ÖNñF’¥√Ñ4	√$BŒ~ïÚì◊.•¢≠&m>.Kºπ$≠m‰†0®*n∂*éz"O}nBò:ı_Ç"ÆXÜë «»»`háâÇ°x=yë„«fN5Lä+'á&ÖíÀí6 V±Ü+PDgüî/fˇjŒn˛AAuƒùâäyG€±‹‰C>Z>
"±d>@πK¢œ8áå&&ù«fÀÇ<7p@⁄òÑÈ{°?œµÒ4
@8-ƒ›3÷jBÏ;‰Iœ†ÛIEV«;$Wøc¯π$/$/h/∏G ŒU˘‡∏/ﬂ;§Ó3æ°ó/Oûù-ùô˛¸‰¨çØI”{>0wêgûk6sH~æ0≠P≠°Ov]v`ê‡∫é•Œÿá/¨wjQ∑4Q⁄∑˛âŸæÎÆÔZﬂ∑˙]ÏxéMΩp^’L¯ÙŸá=Zà<«ÂN>ÁÂv=ø;8kÌ˜Ô≥;ÂÛ‚É„Å‡±Êˇı¸ç˜»gbÂƒßì–~˘
Ï∂Àá·3Ú–âËºÓúa'!1‹í…‚Z˚T˝§w∞MÏ£À¢È≠Ì‚˛…¢üñ&D;$˚ºhã/D;J#∏s9Ãiuô≥å7›U¥øUVÖhi…+JCÿEåŒÌNìŒ¸NÚNPë+ ∆q%ΩìûπŒV{Á¬ﬂ™G¨gÀ5ÊÌ|3˛≠F≥·≠™Ó— ∆·EzSÀ∞kê]ÕÈ’r™w˝ËR˝|ù˚ Œ€È Sü©]ÒdÛ`√§Î¬Id;bªÏÍ√rz;Lú£zõCΩkä›Ú	Rf;iÈœÏ«⁄Ä”ìµ|/i5ı‡°„ây“ˆ 
o◊π˛Óùusu~V\æ™ÍIZû∑«à-A	m©›Hf˜?⁄UıOTı§ºkN—Yïó÷¨ññ◊J /°\gÔ!@u|æˆëv2ÁÉÌøZ‰n ®u◊µö<+öá\Qü±.Ô].U0ŒÈñ€zä‹≤Ì>¡áÌﬁÔúfÏ¶jÒ,≤õ›ZÎâÿ7U §õ§¸Í‚*4ÔÏÓ2áu<◊0“÷ùü£Áu—y‘nûﬁ8ÿ¢’≠¶
o0Mèq6H†ÁºIÉR9´≥x‹◊¬!}Ÿœ* Ø![!≈0jÃÇR≤•∞ºá’+Kµ7qÚ{ç(-Ωuæ≠“……ÓÓü8Âè§èi˘«E+:ÌGsÈ9QÚp6±kúSÙr¶ÁÖDØê•≥[¡n"5°µ!ÈÕÇáápt∑ªi∏Wè⁄(y1[á[áÕ≤ÂÊ-Y·Ò§Ì7qn ~£’ÏöZﬁûõıdnÙﬂ‹Ωœ0âøøøÙ±ﬁo-r?¢Z≈˝ÅûπBNì”g£∞£UUmâºã•|∫.9XmûrÁk]˜4øõ9näòåE†®Å±ÃöÁ°[ﬂM#ÃØö2`¥xLoye2#ìH#2˙◊qå◊1≤C´–÷E†¬ìE41C›¯Esûπ∑¢0.È™Œ·*Ô9Q3¯ÎΩ2öS“|IË Æ¨sM:ûíÉ`¡BíœÔ˙e%“…'Óœ‘–µtüò'ﬁïB…Ç~"ù õÜ»BzVÁGT>V‚ÎØ“)©%è®N	>NTâPÙ.B ‘I¢ˇ±,	yr¬—o˛î<Rx˛'XF¯$X7úNß5a}\Få$iË04?âNa}FBlò®>0ëOq©¿.¸:≈âë±¡∑ 8;?wB"@VÉc|ÜÚˇÿ©ﬂ	Ö QÌ'≠O¸<“¢åC<Ì”∑w`‹˙ê•~PåêùÔ±¡ûGtΩ¿†÷¿åúÒŸ|ﬁq xAy¡‚CºÄ{Å?‹·ﬂ!‹°ﬂΩª√;û°ú©≠	≠üΩ¢3¨5ﬁ5ùµÒŒL?~àS0_0‰VD|0üﬂ%ˆ	”“ç‡Ò˜å˙ÃjM≠ì¶Û≠Ú¯ÎÅ1Ä3@0ÄçCéÉÛ√d@˘@Û@Ú Ú@Ò¿ÚÄ¡¬BﬁÄGCDÉ!C"É#C É›BÚvzw∂uÚv.wÍCÅÁtÍt¶wtw⁄Æ±≠©Æv“ué